#' @import purrr
#' @import dplyr
#' @import tidyr
NULL

#' Numerically stable sum of logged nubmers
#'
#' @param x a numeric vector of logged values.
#' @return log of the sum of the exponentiated entries in x.
log_sum_exp <- function(x) {
  max_x <- max(x)
  log(sum(exp(x - max_x))) + max_x
}
#' Numerically stable mean of logged numbers
#'
#' Use for, e.g., calculating marginal log-likelihood
#'
#' @param x a numeric vector of logged values
#' @return the log of the mean of the exponentiated entries in x.
log_mean_exp <- function(x) log_sum_exp(x) - log(length(x))


#' Likelihood of data under one vowel's model
#'
#' @param mod multivariate normal model (list with mean vector mu and covariance
#' matrix Sigma)
#' @param dat matrix with observations in rows and dimensions in columns, passed to
#' mvtnorm::mvnorm.
#'
#' @export
model_lhood <- function(mod, dat, ...) mvtnorm::dmvnorm(dat, mod$mu, mod$Sigma, ...)

#' Marginal likelihood of data under mixture model
#'
#' Calls \link{\code{model_lhood}} on each model and takes the average (assumes
#' equal prior/mixing weights)
#'
#' @param data matrix with observations in rows and dimensions in columns
#' @param mods list of models in mixture.
#' @param log =TRUE returns log likelihood (default)
#' @param ... additional arguments passed nspvowels::model_lhood (mvtnorm::dmvnorm)
#' @return vector with marginal likelihood for each row in data.
#'
#' @export
marginal_model_lhood <- function(data, mods, log=TRUE, ...) {
  if (log) agg_fun = log_mean_exp
  else     agg_fun = mean

  mods %>%
    map(~ model_lhood(., data, log=log, ...)) %>%
                                        # list of vowels (log)lhood vectors
    do.call(rbind, .) %>%               # vowel x token matrix
    apply(., 2, agg_fun)                # marginal token lhoods
}


#' Use trained models to classify observed formant values
#'
#' @param data Data frame with grouping columns used to generate models
#'   and F1,F2
#' @param models Data frame with column Vowels and list column `model`
#'   (as generated by `train_models`)
#' @param formants Names of formant columns in data. Optional, defaults to
#'   names in models.
#'
#' @return Data frame with one row per data maximum-a-posteriori classification
#' in `model_class`, and correctness in `correct`.
#'
#' @export
classify_mods <- function(data, models,
                          formants=names(models$model[[1]]$mu)) {

  model_groups <- groups(models)
  data <- data %>% group_by_(.dots = model_groups)

  ## make a named list of vowel models for each group
  model_lists <-
    models %>%
    do(models = purrr::set_names(.$model, .$Vowel))

  ## A more efficient implementation than rowwise: get a matrix of all the data in
  ## a group that draws on the same models, to take advantage of vectorization
  ## in `mvnorm`
  ## 
  ## (THe downside is that unnest doesn't want to hold onto the token likelihoods...
  if (is.null(model_groups)) {
    ## no grouping variables: simulate effects of nest + left_bind
    data_and_models <- bind_cols(data_frame(data = list(data)),
                                            model_lists)
  } else {
    data_and_models <- 
      data %>%
      nest() %>%
      left_join(model_lists)
  }

  data_and_models %>%
    mutate(formants = map(data, ~ select_(., .dots=formants) %>% as.matrix()),
           lhoods = map2(models, formants,
                         function(ms, f) map(ms, 
                                             ~ model_lhood(., f))),
           lhoods_mat = map(lhoods,
                            ~ do.call(rbind, .)),
           model_class = map(lhoods_mat, ~ rownames(.)[apply(., 2, which.max)])
           ## token_lhoods = map(lhoods_mat, ~ array_branch(., 2))
           )  %>%
    unnest(data, model_class) %>%
    mutate(correct = model_class == Vowel)
  
}
