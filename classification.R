#' @import purrr
#' @import dplyr
#' @import tidyr
#' @import assertthat
NULL

#' Numerically stable sum of logged nubmers
#'
#' @param x a numeric vector of logged values.
#' @return log of the sum of the exponentiated entries in x.
log_sum_exp <- function(x) {
  max_x <- max(x)
  log(sum(exp(x - max_x))) + max_x
}
#' Numerically stable mean of logged numbers
#'
#' Use for, e.g., calculating marginal log-likelihood
#'
#' @param x a numeric vector of logged values
#' @return the log of the mean of the exponentiated entries in x.
log_mean_exp <- function(x) log_sum_exp(x) - log(length(x))


#' Likelihood of data under one vowel's model
#'
#' @param mod multivariate normal model (list with mean vector mu and covariance
#' matrix Sigma)
#' @param dat matrix with observations in rows and dimensions in columns, passed to
#' mvtnorm::mvnorm.
#'
#' @export
model_lhood <- function(mod, dat, ...) mvtnorm::dmvnorm(dat, mod$mu, mod$Sigma, ...)

#' Marginal likelihood of data under mixture model
#'
#' Calls \link{\code{model_lhood}} on each model and takes the average (assumes
#' equal prior/mixing weights)
#'
#' @param mods list of models in mixture.
#' @param data matrix with observations in rows and dimensions in columns
#' @param log =TRUE returns log likelihood (default)
#' @param ... additional arguments passed nspvowels::model_lhood (mvtnorm::dmvnorm)
#' @return vector with marginal likelihood for each row in data.
#'
#' @export
marginal_model_lhood <- function(mods, data, log=TRUE, ...) {
  if (log) agg_fun = log_mean_exp
  else     agg_fun = mean

  mods %>%
    map(~ model_lhood(., data, log=log, ...)) %>%
                                        # list of vowels (log)lhood vectors
    do.call(rbind, .) %>%               # vowel x token matrix
    apply(., 2, agg_fun)                # marginal token lhoods
}


#' @param data data.frame with columns F1 and F2 (passed to marginal_model_lhood)
#' @param model_list list of models to calculate likelihood
#' @param lhood_fun likelihood function
#' @return data.frame of likelihoods, with one column per model, one row per row
#' in data
apply_model_list <- function(data, model_list, lhood_fun) {
  model_list %>%
    map(~ lhood_fun(., formants_matrix(data))) %>%
    ## do.call(rbind, .) %>%
    ## t() %>%                            # matrix with Dialect as cols
    as_data_frame()                       # data frame with Dialect as cols
}


#' Convert data frame of models to named list
#'
#' @param d data.frame of models
#' @param names_col name of column to be used for names
#' @param model_col ='model' name of column with models
#' @return a named list of models
#' @export
list_models <- function(d, names_col, model_field='model')
  set_names(d[[model_field]], d[[names_col]]) %>% as.list()

#' Convert named list of models to data frame
#'
#' Undoes \code{\link{list_models}}
#' 
#' @param l named list of models
#' @param names_col name of column generated for names
#' @param model_col ='model' name of column generated for models
#' @return a data frame with names in names_col and models in model_col
#' @export
unlist_models <- function(l, names_col, model_col='model')
  data_frame(names(l), l) %>% set_names(c(names_col, model_col))

add_id_col = function(x) mutate(x, id_=row_number())

#' Use trained models to classify observed formant values
#'
#' @param data Data frame with grouping columns used to generate models
#'   and F1,F2
#' @param models Data frame with column Vowels and list column `model`
#'   (as generated by `train_models`).
#' @param formants Names of formant columns in data. Optional, defaults to
#'   names in models.
#'
#' @return Data frame with one row per data x model combination, with likelihood
#'   in lhood, posterior probability in posterior. The model with the highest
#'   posterior for each token has TRUE in posterior_choice.
#'
#' @export
classify_vowels <- function(data, models,
                            formants=names(models$model[[1]]$mu)) {


  assert_that(is.data.frame(models))
  assert_that(is.data.frame(data))

  model_groups <- groups(models)
  if (is.null(model_groups)) {
    data <- data %>% ungroup()
  } else {
    data <- data %>% group_by_(.dots = model_groups)
  }

  ## make a named list of vowel models for each group
  model_lists <-
    models %>%
    do(models = list_models(., 'Vowel'))

  ## A more efficient implementation than rowwise: get a matrix of all the data in
  ## a group that draws on the same models, to take advantage of vectorization
  ## in `mvnorm`
  if (is.null(model_groups)) {
    ## no grouping variables: simulate effects of nest + left_bind
    data_and_models <- bind_cols(data_frame(data = list(data)),
                                            model_lists)
  } else {
    data_and_models <- 
      data %>%
      nest() %>%
      left_join(model_lists)
  }

  data_and_models %>%
    mutate(lhoods = map2(data, models,
                         ~ apply_model_list(.x, .y, model_lhood)),
           posteriors = map(lhoods,
                            . %>%
                              add_id_col() %>%
                              gather(model, lhood, -id_) %>%
                              group_by(id_) %>%
                              mutate(posterior = lhood / sum(lhood),
                                     posterior_choice = posterior==max(posterior)))
           ) %>%
    unnest(map2(data, posteriors,
                ~ inner_join(.x %>% add_id_col(), .y, by='id_') %>%
                  select(-id_))) %>%
    group_by_(.dots=model_groups)
  
}




#' Classify test data with cross-validated models
#'
#' See \code{\link{train_models_indexical_with_holdout}}.
#' 
#' @param data_and_models output of train_models_indexical_with_holdout.
#' @return Data frame with one row per combination of data row and model, with
#'   columns corresponding to the held-out and grouping variables, plus model,
#'   lhood (total log-likelihood of data under model), log_posterior, posterior,
#'   and posterior_choice (1 for the MAP model and 0 otherwise)
#'
#' @export
classify_indexical_with_holdout <- function(data_and_models) {

  lhoods_to_posterior <- function(lhoods) {
    lhoods %>%
      group_by_('model') %>%
      summarise(lhood = sum(lhood)) %>%     # aggregate log-lhood within talkers
      # normalize to get posterior
      mutate(log_posterior = lhood - log_sum_exp(lhood),
             posterior = exp(log_posterior),
             posterior_choice = as.numeric(posterior == max(posterior)))
  }

  data_and_models %>%
    mutate(lhoods = map2(data_test, models,
                         ~ apply_model_list(.x, .y, marginal_model_lhood)),
           posteriors = map(lhoods,
                            . %>%
                              gather(model, lhood, everything()) %>%
                              lhoods_to_posterior())) %>%
    unnest(posteriors)

}
